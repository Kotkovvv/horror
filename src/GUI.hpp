class GUI_touch1 {
    int pix = 500;
    float X1 = 0, Y1 = 0;/* .: */ // для текстуры 
    float x1 = 0, y1 = 0;/* :. */ // для прямоугольника
    float X2 = 0, Y2 = 0;/* :' */ // для текстуры
    float x2 = 0, y2 = 0;/* ': */ // для прямоугольника
    GLuint* tex; // указатель на текстуру
    bool light = 0; // состояние подсветки кнопки
    bool click = 0; // состояние кнопки
public:
    /*
    GLuint* tex - указатель на текстуру,
    int pix- высота текстуры
    int X - x координата правого нижнего угла используемого куска текстуры
    int Y - y координата правого нижнего угла используемого куска текстуры
    float x1, float y1 - координаты правого верхнего угла прямоугольника, который будет рисоваться
    float x2, float y2 - координаты левого нижнего угла прямоугольника, который будет рисоваться
    */
    GUI_touch1(GLuint* tex, int pix, float X, float Y, float x1, float y1, float x2, float y2) {
        X2 = X / pix;
        Y2 = Y / pix;

        this->x1 = x1; this->x2 = x2;
        this->y1 = y1; this->y2 = y2;

        this->tex = tex;
        this->pix = pix;
    }
    /**
        /brief функция обработки мыши

        вызывается в функциях, где обрабатывается мышка. в зависимости от функции(функция нажатия или функция движения мыши)
        мы передаем статус клика. если же мы в эту функцию передаем нажатие кнопки единицу, то она возвращает 1 и
        дальше мы уже можем определять, что делать.

        x - координата мыши по оси x
        y - координата мыши по оси y
        click_status - передаем, нажата ли кнопка мыши

    */
    bool mouse(float x, float y, int click_status) {
        // изменяем координаты мыши. изначально ее координаты определяются как высота и ширина в пикселях,
        // но координаты кнопки в других значениях - к ним и приводим
        x /= W / 2; y /= H / 2;
        x -= 1; y -= 1;
        x *= 0.36; y *= -0.2;
        // смотрим, попадает ли мышка в кнопку
        if (x > x2 && x < x1 && y > y2 && y < y1) {
            light = 1; // включаем подсветку
            click = click_status; // передаем, нажата ли мышка
            return click_status; // возвращаем клик. если мы нажали, то можно сравнить эту функцию там, где мы ее вызываем
            // и дальше уже задавать поведение. эта функция равна 1 - что-то печатаем или делаем
        }
        else {
            light = 0; // не подсвечиваем
            return 0;
        }
    }
    /**
        /brief рисуем кнопку. эта функция вызывается ДО glulookat и в функции, отвечающая за рисование.
    */
    void update() {
        glBindTexture(GL_TEXTURE_2D, *tex);
        glBegin(GL_QUADS);
        if (!light) {
            glTexCoord2d(X2, Y1); glVertex3f(x1, y1, -0.2);
            glTexCoord2d(X2, Y2); glVertex3f(x1, y2, -0.2);
            glTexCoord2d(X1, Y2); glVertex3f(x2, y2, -0.2);
            glTexCoord2d(X1, Y1); glVertex3f(x2, y1, -0.2);
        }
        else {
            glTexCoord2d(X2, Y1+ Y2/2); glVertex3f(x1, y1, -0.2);
            glTexCoord2d(X2, Y2 + Y2 / 2); glVertex3f(x1, y2, -0.2);
            glTexCoord2d(X1, Y2 + Y2 / 2); glVertex3f(x2, y2, -0.2);
            glTexCoord2d(X1, Y1 + Y2 / 2); glVertex3f(x2, y1, -0.2);
        }
        glEnd();
    }
};
class GUI_background1 {
    float pix = 500.0f; // колличество пикселей по высоте и ширине в текстуре
    float X1 = 0.0f, Y1 = 0.0f;  /* .: */ // для текстуры 
    float x1 = 0.0f, y1 = 0.0f;  /* :. */ // для прямоугольника
    float X2 = 0.0f, Y2 = 0.0f;  /* :' */ // для текстуры
    float x2 = 0.0f, y2 = 0.0f;  /* ': */ // для прямоугольника
    GLuint* tex;
    bool key = 1; // состояние текстуры- она есть или нет
public:
    /**
        /brief конструктор класса, где мы можем задать все границы для текстуры и прямоугольника

        GLuint* tex - указатель на текстуру,
        int pix- высота текстуры
        int X2 - x координата правого нижнего угла используемого куска текстуры
        int Y2 - y координата правого нижнего угла используемого куска текстуры
        float x1, float y1 - координаты правого верхнего угла прямоугольника, который будет рисоваться
        float x2, float y2 - координаты левого нижнего угла прямоугольника, который будет рисоваться
    */
    GUI_background1(GLuint* tex, int pix, float X2, float Y2, float x1, float y1, float x2, float y2) {
        this->X2 = X2 / pix;
        this->Y2 = Y2 / pix;

        this->x1 = (x1 * 0.2); this->x2 = (x2 * 0.2);
        this->y1 = (y1 * 0.2); this->y2 = (y2 * 0.2);
        this->tex = tex;
        this->pix = pix;
    }
    /**
        /brief конструктор класса, где мы можем задать все границы для прямоугольника без текстуры

        float x1, float y1 - координаты правого верхнего угла прямоугольника, который будет рисоваться
        float x2, float y2 - координаты левого нижнего угла прямоугольника, который будет рисоваться
    */
    GUI_background1(float x2, float y2, float x1, float y1) {
        this->x1 = (x1 * 0.2); this->x2 = (x2 * 0.2);
        this->y1 = (y1 * 0.2); this->y2 = (y2 * 0.2);
        key = 0; // если вызываем этот конструктор, то говорим, что не используем текстуру для данного объекта
    }
    void update() {
        if (key)glBindTexture(GL_TEXTURE_2D, *tex);  //  если нет текстуры- не биндим ее
        else glBindTexture(GL_TEXTURE_2D, GLU_NONE); // а биндим ничего.пустоту. дыру

        glBegin(GL_QUADS);
        glTexCoord2d(X2, Y1); glVertex3f(x1, y1, -0.2);
        glTexCoord2d(X2, Y2); glVertex3f(x1, y2, -0.2);
        glTexCoord2d(X1, Y2); glVertex3f(x2, y2, -0.2);
        glTexCoord2d(X1, Y1); glVertex3f(x2, y1, -0.2);
        glEnd();

    }
};
//по оси x 1,04
GUI_background1 back(&backg, 100, 100, 100, 1.03, 1, -1.03, -1);///<Класс заднего фона меню
GUI_background1 flashl(&flash, 100, -100, 100, 1.05, -0.1, 0.51, -1);///<Класс рисования фонарика
GUI_touch1 butt(&but, 100, 100, 50, 0.1, 0.1, -0.1, -0.1);///<Класс кнопки
